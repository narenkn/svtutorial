\chapter{Data Types}
\lsvlog adds multiple integer data types, string, chandle, and class
data types and enhances the Verilog event type.

\section{Integer data types}
Integer data types could be either 2-state or 4-state types. Complete
list of integer data types are listed in Table~\ref{dt!table!idt}. All
integer data types are integral as they can be converted to or
assigned from a one-dimensional bit-vector. Other data types such as
\kwpacked \kw{array}, \kwpacked \kwstruct, \kwpacked \kwunion, \kwenum
and \kwtime do also exhibit the integral property.

\begin{table}[h]
\caption{Integer data types}
\centering
\begin{tabular}{|l|l|l|l|l|}
\hline
Data type & 2/4 state & Default Sign-ness & lvalue & rvalue \\
\hline \hline
\kwshortint & 2-state & signed & $-2^{15}$ & $2^{15}-1$ \\
\hline
\kwint & 2-state & signed & $-2^{31}$ & $2^{31}-1$ \\
\hline
\kwlongint & 2-state & signed & $-2^{63}$ & $2^{63}-1$ \\
\hline
\kwbyte & 2-state & signed & $-2^7$ & $2^7-1$ \\
\hline
\kwbit & 2-state & unsigned & \multicolumn{2}{l}{user-defined vector size} \\
\hline
\kwlogic & 4-state & unsigned & \multicolumn{2}{l}{user-defined vector size} \\
\hline
\kwreg & 4-state & unsigned & \multicolumn{2}{l}{user-defined vector size} \\
\hline
\kwinteger & 4-state & signed & $-2^{31}$ & $2^{31}-1$ \\
\hline
\kwtime & 4-state & unsigned & $0$ & $2^{64}-1$ \\
\hline
\end{tabular}
\label{dt!table!idt}
\end{table}

Every bit of a 2-state data-type could hold the value '0' or '1',
whereous each bit of a 4-state data-type could hold values '0', '1',
'X' or 'Z'.

All integer data types could be either \kwsigned or \kwunsigned. It becomes
important to understand sign-ness to understand the boundaries of each
data-type. When an integer data type is declared to be \kwunsigned, it
would have range from $0$ to $2^n-1$, where $n$ is the number of bits
in the type.

\section{Floating-point data types}
\lvlog already defines \kwreal, which is equivalent to \lc's
\kw{double} data-type. \lsvlog defines \kwshortreal data-type, that is
equivalent to \lc's \kw{float}. In general implementations of \lc
compilers, \kw{float} has 7 decimal precision, whereous \kw{double}
has a precision of 15.

\section{void}
The \kwvoid data type represents nonexistent data. This type can be
specified as the return type of functions to indicate no return
value. This type can also be used for members of tagged unions.

\section{chandle}
The \kwchandle data type represents storage for pointers. Its only
application is to store DPI returned pointers. \lsvlog can neither
create nor destroy \lc pointers. \kwchandle have initial value as
\kwnull. \kwchandle could be used in boolean equations to test for
equality \texttt{==, !=, ===, !==}. In boolean context, a \kwchandle
evaluates to 0 if \kwnull or to 1 otherwise. It should be obvious that
\kwchandle could be used as arguments to \kwfunction or \kwtask but
not as ports.

\section{string}
\lsvlog's \kwstring is a built-in data-type. It is dynamic as its
length may vary during simulation. It could be assigned from a
string literal. \kwstring data-type allows indexing single or a group
of characters. Unlike \lc, \lsvlog's \kwstring doesn't contain the
special character '\textbackslash{}0'.

Special string operators exists for \kwstring data type. These
operators are invoked only if either of operands is a \kwstring data
type. Otherwise, when both operands are string literals, the behaviour
would be comparable with Verilog, where integer operators are invoked
in most cases. If the result of the operator is used in another
expression involving string types, it is implicitly converted to the
string type.
\begin{description}
\item{{\bf Equality operator ==}} \hfill \\ Checks whether the two
  strings are equal. Result is 1 if they are equal and 0 if they are
  not.
\item{{\bf Inequality operator !=}} \hfill \\ Logical negation of
  Equality operator.
\item{{\bf Comparison operators $<, >, <=, >=$}} \hfill \\ Relational
  operators return 1 if the corresponding condition is true using the
  lexicographical ordering of the two strings under consideration.
\item{{\bf Concatenation \{~\}}} \hfill \\ The string concatenation
  operator evaluates each constituent expressions to string before
  concatenating it. The result is of type string.
\item {{\bf Replication \{$M$\{~\}\}}} \hfill \\ Multiplier must be of
  integral type and can be non-constant. If multiplier is non-constant
  or if the expression is of type string, the result is a string
  containing $M$ concatenated copies of expression. If expression is a
  literal and the multiplier is constant, the expression behaves like
  numeric replication in Verilog.
\item {{\bf Indexing [~]}} \hfill \\ Returns a byte, the ASCII code at
  the given index. Indexes range from $0$ to $N-1$, where $N$ is the
  number of characters in the string. If index is out of range, the
  operator returns $0$.
\end{description}

\begin{table}
\begin{tabular}{p{0.6\textwidth} p{0.4\textwidth}}
\begin{lstlisting}[label=dt!literal!struct, caption=Structure Literals]
string s1;
string s2 = "abcdef\n";
string s3 = "ghijkl\0";
string s4 = "hello";
bit [11:0] b = 12'ha41;
string s2 = string'(b);

typedef reg [15:0] r_t;
r_t r;
integer i = 1;
string s5 = "";
string s6 = {"Hi", s5};

r = r_t'(s6);
s5 = string'(r);
s5 = "Hi";
s5 = {5{"Hi"}};
s6 = {i{"Hi"}};
r = {i{"Hi"}};
s6 = {i{s5}};
s6 = {s6,s5};
s6 = {"Hi",s5};
r = {"H",""};
b = {"H",""};
s2[0] = "h";
s2[0] = "cough";
s2[1] = "\0";
\end{lstlisting}
&
\begin{tbldesc}
\begin{verbatim}


Line 1: initialised to ""
Line 2: OK
Line 3: '\0' is removed from string
Line 4: OK
Line 5: OK
Line 6: converted to 16'h0a41
  Note the typecasting operator

Line 9: reg init with 'x
Line 11: explicit string init to ""
Line 12: OK value "Hi"
Line 14: OK value 16'h4869
Line 15: OK value "Hi"
Line 16: OK value "Hi"
Line 17: OK value "HiHiHiHiHi"
Line 18: OK (non constant replication)
Line 19: Invalid (non constant replication)
Line 20: OK value "HiHiHiHiHiHi"
Line 21: OK
Line 22: OK value "HiHiHiHiHiHiHi"
Line 23: 16'4800 ("" is converted to 8'b0)
Line 24: OK value 12'h048
Line 25: OK
Line 26: OK, same as Line 25
Line 27: s2[1] unchanged, "\0" is not assigned
\end{verbatim}
\end{tbldesc}
\end{tabular}
\end{table}

The methods of \kwstring data-type are

\begin{description}

\item{{\bf len}}
\begin{Verbatim}[formatcom=\color{blue}, fillcolor=\color{cyan}]
function int len()
\end{Verbatim}
Return value is the length of the string, excluding any termination
character. For an empty string "", the return value is $0$.

\item{{\bf putc}}
\begin{Verbatim}[formatcom=\color{blue}, fillcolor=\color{cyan}]
task putc(int i, byte c)
\end{Verbatim}
Task replaces the $i^{th}$ character in \kwstring with the given
value `c'. `c' is checked for non-zero before action is taken. If
index $i$ is out of range, then string is un-affected.

\item{{\bf getc}}
\begin{Verbatim}[formatcom=\color{blue}, fillcolor=\color{cyan}]
function byte getc(int i)
\end{Verbatim}
Returns the ASCII code of the $i^{th}$ character in \kwstring.

\item{{\bf toupper}}
\begin{Verbatim}[formatcom=\color{blue}, fillcolor=\color{cyan}]
function string toupper()
\end{Verbatim}
Returns a string with characters converted to uppercase, without
affecting the original \kwstring.

\item{{\bf tolower}}
\begin{Verbatim}[formatcom=\color{blue}, fillcolor=\color{cyan}]
function string tolower()
\end{Verbatim}
Returns a string with characters converted to lowercase, without
affecting the original \kwstring.

\item{{\bf compare}}
\begin{Verbatim}[formatcom=\color{blue}, fillcolor=\color{cyan}]
function int compare(string s)
\end{Verbatim}
Returns value of \kw{ANSI} \lc \kw{strcmp} function.

\item{{\bf icompare}}
\begin{Verbatim}[formatcom=\color{blue}, fillcolor=\color{cyan}]
function int icompare(string s)
\end{Verbatim}
Returns value of \kw{ANSI} \lc \kw{strcmp} function, but is case
in-sensitive.

\item{{\bf substr}}
\begin{Verbatim}[formatcom=\color{blue}, fillcolor=\color{cyan}]
function string substr(int i, int j)
\end{Verbatim}
Returns a new \kwstring that is a substring formed by characters in
position $i$ through $j$. An empty-string is returned if either $i <
0$ or $j < i$ or $j >= str.len()$.

\item{{\bf atoi, atohex, atooct, atobin, atoreal}}
\begin{Verbatim}[formatcom=\color{blue}, fillcolor=\color{cyan}]
function integer atoi()
function integer atohex()
function integer atooct()
function integer atobin()
function real    atoreal()
\end{Verbatim}
Returns the number after interpretting the string as either decimal,
hexadecimal, octal, binary or real formats (respective
functions). These functions expect raw strings and are not \lvlog
integer literal compliant (cannot interepret \lvlog int literal).

\item{{\bf itoa, hextoa, octtoa, bintoa, realtoa}}
\begin{Verbatim}[formatcom=\color{blue}, fillcolor=\color{cyan}]
task itoa(integer i)
task hextoa(integer i)
task octtoa(integer i)
task bintoa(integer i)
task realtoa(real r)
\end{Verbatim}
Family of method to store the ASCII real representation of argument
into the string in the implied format.

\end{description}
